"""Backwards-compat shim for top-level backups.py

This file used to be the canonical implementation at repository root. The
package layout was reorganized so the implementation now lives under
``researcharr/_backups_impl.py`` and the package exposes ``researcharr.backups``.

Keep a tiny shim here so any import paths that still find this file will
delegate to the package implementation and ensure both ``backups`` and
``researcharr.backups`` map to the same module object where possible.
"""

import sys
from importlib import import_module

# Import all public names from the package internal implementation.
try:
    impl = import_module("researcharr._backups_impl")
    globals().update({k: getattr(impl, k) for k in dir(impl) if not k.startswith("__")})
except Exception:
    # If the package implementation isn't importable in some test contexts,
    # leave this module minimal â€” tests that inject a top-level `backups`
    # module into sys.modules will still take precedence.
    impl = None

# Ensure both keys refer to the same module object when possible.
this_mod = sys.modules.get(__name__)
if this_mod is not None:
    # ensure package submodule key exists and points to same module
    sys.modules.setdefault("researcharr.backups", this_mod)
    """Backwards-compat shim for top-level backups.py

    This file used to be the canonical implementation at repository root. The
    package layout was reorganized so the implementation now lives under
    ``researcharr/_backups_impl.py`` and the package exposes ``researcharr.backups``.

    Keep a tiny shim here so any import paths that still find this file will
    delegate to the package implementation and ensure both ``backups`` and
    ``researcharr.backups`` map to the same module object where possible.
    """

    import sys
    from importlib import import_module
    from typing import Any


    """Backwards-compat shim for top-level backups.py

    This shim delegates to the package internal implementation at
    ``researcharr._backups_impl`` and ensures sys.modules aliases are set so
    tests that inject a top-level ``backups`` module still behave correctly.
    """

    import sys
    from importlib import import_module
    from typing import Any


    def _try_load_impl() -> Any:
        try:
            impl = import_module("researcharr._backups_impl")
            for k in dir(impl):
                if not k.startswith("__"):
                    globals()[k] = getattr(impl, k)
            return impl
        except Exception:
            return None


    _IMPL = _try_load_impl()

    # Ensure package aliasing in sys.modules so importlib.reload() can find
    # the same module object under 'researcharr.backups' when appropriate.
    this_mod = sys.modules.get(__name__)
    if this_mod is not None:
        sys.modules.setdefault("researcharr.backups", this_mod)

    # If test code injected a top-level "backups" module object into sys.modules
    # prefer that as the canonical implementation but also alias it under the
    # package name so reload() semantics behave as tests expect.
    top = sys.modules.get("backups")
    if top is not None and top is not this_mod:
        sys.modules.setdefault("researcharr.backups", top)
