version: '3.8'

services:
  researcharr:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: researcharr-dev
    # Map the app port so you can browse the UI from the host
    ports:
      - "2929:2929"
      # Optional: expose a debug port for debugpy if you enable it below
      - "5678:5678"
    environment:
      - PYTHONUNBUFFERED=1
      - FLASK_ENV=development
      - LOGLEVEL=DEBUG
      - WEBUI_PORT=2929
      # Useful runtime debugging overrides
      - RUN_JOB_CONCURRENCY=1
      - JOB_TIMEOUT=0
    volumes:
      # Mount the project source into the container for live edits & immediate debugging
      - ./:/app:delegated
      # Persist runtime config and DB on host so you can inspect files easily
      - ./config:/config:rw
      - ./logs:/config/logs:rw
    tty: true
    stdin_open: true
    # Use a simple command that ensures any local changes to requirements are installed
    command: >
      /bin/sh -lc "pip install --no-cache-dir -r requirements.txt || true && \ 
      # OPTIONAL: to run under debugpy, uncomment the next line and comment the plain run line
      # python -m debugpy --listen 0.0.0.0:5678 --wait-for-client -m runpy /app/run.py && \
      python -u /app/run.py"
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "5"

# Usage tips:
# - Start in the foreground to stream logs: docker compose -f docker-compose.dev.yml up --build
# - Follow logs from another terminal: docker compose -f docker-compose.dev.yml logs -f researcharr
# - Inspect cron logs: tail -f logs/cron.log (on the host) or docker exec -it researcharr-dev tail -f /config/cron.log
# - For remote debugging: install debugpy in the container and uncomment the debugpy line above; attach your IDE to port 5678
